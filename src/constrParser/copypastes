copy/pastes: 

import "constrParser.parserMeas";

import "constrParser.logicManage";

logicManage.constructionToFormula rule6;

Document.read "allrules";

pdflatex rule2.tex; pdflatex rule3.tex;

parserMeas.stringIntoConstruction stri;

--------------------------------------

tSchema similarBinary:(measStickG,measStickG,interLogic) =
    source t:formula <- prefixBinRel[b:binRel, s1:?P:seg, s2:?P':seg] 
    target t':formula <- prefixBinRel[b':binRel, p1:?P:seg, p2:?P':seg]
    antecedent #:metaTrue <- sameAs[b:binRel,b':binRel],
               #:metaTrue <- sameAs[s1:?P:seg,p1':?P:seg],
               #:metaTrue <- sameAs[s2:?P':seg,p2':?P':seg]
    consequent :metaTrue <-close[t:formula,t':formula]
    strength 1000

tSchema similarTernary:(measStickG,measStickG,interLogic) =
    source t:formula <- prefixTerRel[tr:terRel, s1:?P:seg, s2:?P':seg, s3:?P'':seg] 
    target t':formula <- prefixTerRel[tr':terRel, p1:?P:seg, p2:?P':seg, p3:?P'':seg]
    antecedent #:metaTrue <- sameAs[tr:terRel,tr':terRel],
               #:metaTrue <- sameAs[s1:?P:seg,p1':?P:seg],
               #:metaTrue <- sameAs[s2:?P':seg,p2':?P':seg],
               #:metaTrue <- sameAs[s3:?P'':seg,p3':?P'':seg]
    consequent :metaTrue <-close[t:formula,t':formula]
    strength 1000

-----------------------
MEASSTICK:
val stri = "r1 V s1 V s2 L s1 s2 * S s2 s1 A  r2 V s1 V s2 V s3 E s1 s2 s3* C s3 s2 s1 A r3 V s1 V s2 ~ S s1 s2 > ~ L s2 s1 > s1 = s2 A r4 V s1 ~ L u1 s1 A r5 V s1 V s2  S s1 s2 > ~ S s2 s1 A r6 V s1 V s2 V  s3 E s1 s2 s3 > L s3 s2 & L s3 s1";

val rule1 = parserMeas.parseWrap "r1 V s1 V s2 L s1 s2 * S s2 s1";

val rule2 = parserMeas.parseWrap "r2 V s1 V s2 V s3 E s1 s2 s3* C s3 s2 s1";

val rule3 = parserMeas.parseWrap "r3 V s1 V s2 ~ S s1 s2 > ~ L s2 s1 > s1 = s2";

val rule4 = parserMeas.parseWrap "r4 V s1 ~ L u1 s1";

val rule5 = parserMeas.parseWrap "r5 V s1 V s2  S s1 s2 > ~ S s2 s1";

val rule6 = parserMeas.parseWrap "r6 V s1 V s2 V s3 E s1 s2 s3 > L s3 s2 & L s3 s1";

val rule6 = parserMeas.stringIntoConstruction "r6 V s1 V s2 V s3 E s1 s2 s3 > L s3 s2 & L s3 s1";

============================================================================
MOTIONPATH:
val rule1 = parserMotion.parseWrap "r1 V s1 V s2 F s1 s2 * C s2 s1";

val rule2 = parserMotion.parseWrap "r2 V s1 V s2 V s3 a s1 s2 s3* T s3 s2 s1";

val rule3 = parserMotion.parseWrap "r3 V s1 V s2 ~C s1 s2 > ~ F s2 s1 > s1 = s2";

val rule4 = parserMotion.parseWrap "r4 V s1 ~ F u1 s1";

val rule5 = parserMotion.parseWrap "r5 V s1 V s2 C s1 s2 > ~C s2 s1";

val rule6 = parserMotion.parseWrap "r6 V s1 V s2 V s3 a s1 s2 s3 & ~ p1 = o1 > F s3 s2 & F s3 s1";

parserMotion.stringIntoConstruction "r1 V p1 V p2 F p1 p2 * F p2 p1 A r2 V p1 V p2 V p3 a p1 p2 p3* T s3 s2 s1 A r3 V s1 V s2 ~ T s1 s2 > ~ F s2 s1 > s1 = s2 A r4 V s1 ~ F u1 s1 A r5 V s1 V s2 T s1 s2 > ~ T s2 s1 A r6 V p1 V p2 V p3 a p1 o1 p3 & ~ p2 = o1 > F p3 p2 & F p3 p1 A r7 V p1 V p3 a p1 o1 p3 > p1 = p3"

parserMotion.stringIntoConstruction "r7 V p1 V p3 a p1 o1 p3 > p1 = p3";

val all = parserMotion.stringIntoConstruction stri;

val stri = "r1 V s1 V s2 F s1 s2 * C s2 s1 A  r2 V s1 V s2 V s3 a s1 s2 s3* T s3 s2 s1 A r3 V s1 V s2 ~C s1 s2 > ~ F s2 s1 > s1 = s2 A r4 V s1 ~ F u1 s1 A r5 V s1 V s2 C s1 s2 > ~C s2 s1 A r6 V s1 V s2 V s3 a s1 s2 s3 & ~ p1 = o1 > F s3 s2 & F s3 s1 A r7 V p1 V p3 a p1 o1 p3 > p1 = p3";

bigConstruction = parserMotion.joinAnds 1 [rule1, rule2, rule3, rule4, rule5, rule6]

val {conSpecsData, constructionsData, knowledge, strengths, transferRequests, typeSystemsData} = it;
val {conSpecN, constructions ,name} = r1
val [r15,r6,r5,r4,r3,r33,r2,r1] = constructionsData

parserMeas.joinAnds 1 [r1,r2,r3,r4,r5,r6];

val {conSpecN, construction, name} = r1;
val r1 = construction;


construction is really:

Construction.TCPair ({token = token, constructor = constructor}, cs)
  datatype construction = Construction.TCPair of {token : string * string,
                                     constructor : string * (string list * string)} 
                                    * construction list
                        | Construction.Source of string * string (ownname, generic)
                        | Reference of string * string (ownname, generic)

---------------
tSchemas

import measStick
import motionPath
import metaLogic

typeSystem interMeasPathT =
    imports measStick, motionPath, metaLogicT
    types
    order

conSpec interMeasPath:interMeasPathT =
    imports metaLogic
    constructors
        close :[formula, formula] -> metaBool,
        closeBinRel :[binRel, binRel] -> metaBool,
        closeTerRel :[terRel, terRel] -> metaBool,
        similar :[seg, obj] -> metaBool,
        equal :[binRel, binRel] -> metaBool,
        alike :[obj, obj] -> metaBool

tSchema similarTernary:(measStickG,motionPathG,interMeasPath) =
    source t:formula <- prefixTerRel[t0: terRel, s1:seg, s2:seg, s3:seg]
    target t':formula <- prefixTerRel[t0': terRel, p1':obj, p2':obj, p3':obj] 
    antecedent :metaTrue <-alike[s1:seg,p1':obj],
               :metaTrue <-alike[s2:seg,p2':obj],
               :metaTrue <-alike[s3:seg,p3':obj],
               :metaTrue <-closeTerRel[t0:terRel,t0':terRel]
    consequent :metaTrue <-close[t:formula,t':formula]
    strength 80


tSchema negNotClose:(measStickG,motionPathG,interMeasPath) =
    source t:formula
    target t':formula <- logicApplyUnary[n:not, f:formula]
    antecedent :metaTrue <-close[t:formula,f:formula]
    consequent :metaFalse <-close[t:formula,t':formula]
    strength 10

tSchema negClose:(measStickG,motionPathG,interMeasPath) =
    source t:formula <- logicApplyUnary[n:not, f:formula]
    target t':formula <- logicApplyUnary[n':not, f':formula]
    antecedent :metaTrue <-close[f:formula,f':formula]
    consequent :metaTrue <-close[t:formula,t':formula]
    strength 50

#tSchema doubleNeg:(measStickG,motionPathG,interMeasPath) = #which way should this go?
#    source t:formula
#    target t':formula <- logicApplyUnary[n1:not, f1:formula <-logicApplyUnary[n2:not, t:formula]]
#    antecedent : metaTrue <-close[t:formula,t':formula],
#    consequent : metaTrue <-close[t:formula,f1':formula]
#    strength 1

tSchema similarBinary:(measStickG,motionPathG,interMeasPath) =
    source t:formula <- prefixBinRel[b: binRel, s1: seg, s2: seg] 
    target t':formula <- prefixBinRel[b': binRel, p1: obj, p2: obj]
    antecedent :metaTrue <-alike[s1:seg,p1:obj],
               :metaTrue <-alike[s2:seg,p2':obj],
               :metaTrue <-closeBinRel[b:binRel,b':binRel]
    consequent :metaTrue <-close[t:formula,t':formula]
    strength 80

tSchema similarBinaryInfix:(measStickG,motionPathG,interMeasPath) =
    source t:formula <- binInfixRel[s1: seg, b: binRel, s2: seg] 
    target t':formula <- binInfixRel[p1: obj, b': binRel, p2: obj]
    antecedent :metaTrue <-alike[s1:seg,p1:obj],
               :metaTrue <-alike[s2:seg,p2':obj],
               :metaTrue <-closeBinRel[b:binRel,b':binRel]
    consequent :metaTrue <-close[t:formula,t':formula]
    strength 80

tSchema rewardAllign:(measStickG,motionPathG,interMeasPath) =
    source t:formula <- logicInfixOp[f1:formula,a:and,f2:formula]
    target t':formula <- logicInfixOp[f1':formula, a':and, f2':formula]
    antecedent :metaTrue <-close[f1:formula,f1':formula],
               :metaTrue <-close[f2:formula,f2':formula]
    consequent :metaTrue <-close[t:formula,t':formula]
    strength 200

#tSchema comClose:(measStickG,motionPathG,interMeasPath) = 
#    source f:formula 
#    target f':formula 
#    antecedent :metaTrue <-close[f:formula,f':formula]
#    consequent :metaTrue <-close[f':formula, f:formula]
#    strength 1

tSchema equivClose:(measStickG,motionPathG,interMeasPath) =
    source t:formula <- logicInfixOp[f1:formula, e:equiv ,f2:formula]
    target t':formula <- logicInfixOp[f1':formula, e:equiv , f2':formula]
    antecedent :metaTrue <-close[f1:formula,f1':formula],
               :metaTrue <-close[f2:formula,f2':formula]
    consequent :metaTrue <-close[t:formula,t':formula]
    strength 100

tSchema infixClose:(measStickG,motionPathG,interMeasPath) =
    source t:formula <- logicInfixOp[f1:formula, e:binary ,f2:formula]
    target t':formula <- logicInfixOp[f1':formula, e:binary , f2':formula]
    antecedent :metaTrue <-close[f1:formula,f1':formula],
               :metaTrue <-closeBinRel[e:binary,e':binary],
               :metaTrue <-close[f2:formula,f2':formula]
    consequent :metaTrue <-close[t:formula,t':formula]
    strength 100

tSchema eqlIsClose:(measStickG,motionPathG,interMeasPath) =  #apparently wrong syntax here?
    source t:?P:binRel 
    target t':?P:binRel 
    antecedent :metaTrue <-equal[t:binRel,t':binRel]
    consequent :metaTrue <-closeBinRel[t:binRel,t':binRel]
    strength 10

tSchema quantDrop:(measStickG,motionPathG,interMeasPath) = 
    source t:formula <- logicApplyQuant[q:forall, s:seg, f:formula]
    target t':formula <- logicApplyQuant[q':forall, s':obj, f':formula]
    antecedent :metaTrue <-alike[s:seg,s':obj],
               :metaTrue <-close[f:formula,f':formula]
    consequent :metaTrue <-close[t:formula,t':formula]
    strength 100

#tSchema quantunify:(measStickG,motionPathG,interMeasPath) = 
#    source t:formula <- logicApplyQuant[q:forall, s:seg, f:formula]
#    target t':formula <- logicApplyQuant[q':forall, s':obj, f':formula]
#    antecedent :metaTrue <-alike[s:seg,s':obj],
#               :metaTrue <-close[f:formula,f':formula]
#    consequent :metaTrue <-close[t:formula,t':formula]
#    strength 7

# concepts/formulas!
#tSchemas concerning forAlls

# type vars only work if nthey're also in consequent